# 注意事项和小技巧

## 形如(n,)的秩为1的array
```python
import numpy as np

a = np.random.randn(5)  # 生成5个随机变量
print(a)        #单括号数组形式: [ 0.1974803   0.13017237 -1.64577213 -0.63429529 -0.46014399]
print(a.shape) # (5,)
print(a.T)  #[ 0.1974803   0.13017237 -1.64577213 -0.63429529 -0.46014399]
print(np.dot(a,a.T))    # a real number : 13.6658537649
```

*  对于类似这种(5,)结构的array秩为1的**数组**, **最好不要使用这种数组**,由于转置相乘会得到一个实数,这种数组不利于矩阵的计算 
*  相反,利用下面这种矩阵形式

```python
import numpy as np

a = np.random.randn(5, 1)
print(a)
# 双括号矩阵
# [[ 0.49134677]
#  [-0.38182537]
#  [-0.59076716]
#  [-0.75150525]
assert (a.shape == (5,1))       # 为了避免出现矩阵shape的bug,常使用assert检查确保这是一个向量
print(a.shape)  # (5, 1)
print(np.dot(a, a.T))
# 此时得到的就会是一个矩阵
# [[ 0.36646024  0.37799055 -0.08788292  0.20193284 -0.02553946]
#  [ 0.37799055  0.38988365 -0.09064807  0.20828646 -0.02634303]
#  [-0.08788292 -0.09064807  0.0210757  -0.04842667  0.00612476]
#  [ 0.20193284  0.20828646 -0.04842667  0.1112723  -0.01407316]
#  [-0.02553946 -0.02634303  0.00612476 -0.01407316  0.0017799 ]]

```

* 同样可以常使用`reshape((5,1))`来确保得到的是一个矩阵.这个方法把数组转化为矩阵形式.利用此方法可以把代码1中的秩为1数组转化为矩阵 
 
## 切片操作
```python
import numpy as np

a =np.array( [[1, 2, 3], [4, 5, 6], [7, 8, 9]])
b = np.array([1,2,3])
print(b != 1)
print(a[b != 1,:2])

print(a != 1)
print(a[a != 1])


#-------输出
[False  True  True]
[[4 5]
 [7 8]]
[[False  True  True]
 [ True  True  True]
 [ True  True  True]]
[2 3 4 5 6 7 8 9]
```

* 这种语法只能用于numpy数组
* b输出为一个1*3的布尔数组.这里先把实数1扩展为1*3的`[1,1,1]`然后和b比较,输出`[False  True  True]`
* 这里对a执行切片操作,`切片[]内`第一个参数对应对a的行运算,第二个参数为列运算.
    * 这里语句的意思是取`[False  True  True]`对应为True的index行,前两列
* 注意在切片内作为参数的array的维度.
    * 这里a是二维的,首先用一维的布尔数组作为参数,选取的就是波尔数组index对应的行号,返回仍然是二维数组.
    * 如果用二维的布尔数组作为参数,就会同时比较对应的行和列,获取的就是一维的数组