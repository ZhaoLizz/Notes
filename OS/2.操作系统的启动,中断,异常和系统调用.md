## 概览

![](http://ww1.sinaimg.cn/large/0077h8xtly1fvmxhgmigij309u0bcq84.jpg)

DISK: 存放OS

BIOS: 基本I/O处理系统 

BootLoader: 加载OS

定义:

* 系统调用(来源于应用程序)
  * **应用程序**主动向操作系统发出服务请求
* 异常(来源于不良的应用程序)
  * 非法指令或者其他坏的处理状态(应用程序出现问题,交给操作系统来处理)
* 中断(来源于外设)
  * 来自不同的硬件设备的计时器和网络的中断

中断,异常,外设三者的联系和区别:

* 源头
  * 中断:外设(比如键盘的敲击信号,鼠标的移动信号等)
  * 异常: 应用程序意想不到的行为
  * 系统调用:应用程序请求操作提供服务(比如打开文件,读写文件)
* 处理时间
  * 中断: 异步(异步说明不知道什么时候会产生)
  * 异常: 同步(在执行某条指令后一定会产生)
  * 系统调用: 异步或同步
    * 同步: 执行一条指令后马上产生系统调用
    * 异步: 有可能应用程序发出系统调用指令后立即去处理其他事情,操作系统去处理系统调用指令,一段时间后返回给应用程序响应数据, **这个返回数据的过程是异步的**

* 响应
  * 中断: 持续,对用户的应用程序是透明的
  * 异常: 杀死或者重新执行意想不到的应用程序指令
  * 系统调用: 等待和持续



## 操作系统的中断,异常和系统调用

### 处理机制

**中断**:

* 中断会打断当前的执行,去执行一个紧急的的响应事件,所以需要在**硬件和软件**方面做相应的保护 ,使得被打断的程序可以继续执行
* 硬件方面:
  * 设置中断标记(中断标记由CPU初始化),系统维护一个 **中断id : 地址** 的表,每个外设具有一个独立的中断id,产生中断时,系统根据id值找到地址去做响应的处理

* 软件方面:
  * 保存当前的处理状态,使得被打断的程序可以继续执行
  * 执行中断服务程序处理(比如处理鼠标的移动)
  *  处理完中断历程后,清除中断标记
  * 恢复之前保存的处理状态

**异常**:

* 异常也具有一个编号
* 处理异常的过程:
  * 保存现场
  * 异常处理
    * 或者杀死产生异常的程序
    * 或者重新执行异常指令
  * 恢复现场

**系统调用**:

* 一般程序主要是通过高层次的API接口而不是直接进行系统调用

* 应用程序通过API访问系统调用的接口,访问这个接口后, 会触发一个 **用户态到内核态的转换**
  * 用户态特权级比较低,不能直接访问某些指令和IO
  * 内核态:操作系统运行过程中CPU处于的一个状态,特权级高,可以执行 **任何一条指令**
  * 系统调用过程会跨越**操作系统-应用程序**的边界,产生一定的开销(因为操作系统的内核堆栈和应用程序的堆栈是相互分离的)
* 跨越操作系统边界产生的开消
  * 在执行时间上的开消超过程序调用
  * 建立 **中断/异常/系统调用号 : 对应服务例程** 映射关系表的**初始化开销**
  * 由于操作系统不信任应用程序,所以操作系统会对应用程序发送的参数 **进行验证检查**,造成开销
  * 在传递参数时,操作系统需要把数据从内核态映射到用户态的地址空间, 带来**内存拷贝开销**
  * 内核态独立拥有地址空间

