# 字节与位运算

## 基本概念
* `bit`:位.一个二进制数据0或1是一个bit
* `byte`:字节.存储空间的基本计量单位.
    * 1 byte = 8 bit
    * short = 2 byte
    * int = 4 byte
    * long = 8 byte
    * float = 4 byte
    * double = 8 byte
    * `1 英文字符 = 1 byte = 8 bit`
    * `1 汉字 = 2 byte = 16 bit`

## 基础理论
* String对象的getBytes()方法是得到每个字符的ASCII,然后组成数组
```
String bin = Integer.toBinaryString(10);        //bin : 1010
System.out.println(Arrays.toString(bin.getBytes()));
[49, 48, 49, 48]
```
* byte是一个字节,8位二进制数字,这8个二进制数字中第一个位(最高位)是**符号位**
    * `0000 0001`代表数字1,`1000 0001`代表-1

## 位运算

`A = 0011 1100`  
`B = 0000 1101`
* A,B如果位数不同,进行位运算时就在位数少的左侧补齐0  
* 0x..表示16进制,0b...表示2进制,0...表示8进制
* 常见的0xFF转化为二进制就是1111 1111,与0xFF进行与&运算就是只取当前二进制数的最低8位

| 操作符 |                                        描述                                        |             例子              |                         |
| ------ | ---------------------------------------------------------------------------------- | ----------------------------- | ----------------------- |
| ＆     | 如果相对应位都是1，则结果为1，否则为0                                              | （A＆B），得到12，即0000 1100 |                         |
|        | 如果相对应位都是0，则结果为0，否则为1                                              | （A                           | B）得到61，即 0011 1101 |
| ^      | 如果相对应位值相同，则结果为0，否则为1                                             | （A ^ B）得到49，即 0011 0001 |                         |
| 〜     | 按位补运算符翻转操作数的每一位，即0变成1，1变成0。                                 | （〜A）得到-61，即1100 0011   |                         |
| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。                               | A << 2得到240，即 1111 0000   |                         |
| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。                               | A >> 2得到15即 1111           |                         |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111        |                         |




